# Basando la imagen en Node 12
FROM node:12

# Copiar primero los package de las depedencias, porque
# de ello dependerá si Docker detecta cambios en dichos
# ficheros y entonces decidirá si reciclar o no la capa
# posiblemente cacheada de RUN npm install.
# 
# COPY acepta N elementos, y al final la ruta destino.
COPY ["package.json", "package-lock.json", "/usr/src/"]

# Ubica a Docker en el directorio /usr/src
WORKDIR /usr/src

# Instala las dependencias del proyecto... reciclará
# esta capa si no detectó cambios en la capa de COPY
RUN npm install

# Copia todos los archivos del directorio donde se
# encuentra el contexto de Docker (dockerfile) hacia
# la ruta especificada.
# 
# Docker no reescribirá los package.json porque ya se
# dio cuenta que no hay cambios entre el COPY anterior
# y este, así que los omite
COPY [".", "/usr/src/"]

# Expone el puerto 3000 en el contenedor
EXPOSE 3000

# Establece el comando por sobre el que correrá el
# contenedor permanentemente
CMD ["npm", "run", "start"]

# En modo de desarrollo, interesa que nodemon se ejecute
# para poder rebuildear en tiempo real la imagen de Docker
# y así compilar rápido.
# --> CMD ["npx", "nodemon", "index.js"]
# Recordar que npx es una forma de correr un comando del que
# su dependencia no está instalada en el bash sino en el proyecto
# de NPM mismo.

# SHELL FORM vs EXEC FORM
# El sig. comando es corrido por Docker como un comando hijo del
# shell (es decir, como si fuese ./bin/sh -c <my_command>):
# --> CMD npm run start
# Mientras que al sig. comando Docker lo corre directamente sin
# intermediar con shell:
# --> CMD ["npm", "run", "start"]

# Lo anterior se puede comprobar buildeando la imagen con ambos
# comandos y ejecutando el comando $ docker exec <container_name> ps -ef
# sobre el contenedor corriendo.}
# Ahí se verá que en SHELL FORM, el comando
# se presenta como un hijo del proceso de SHELL (lo que ignora el SIGTERM),
# mientras que EXEC FORM al ser un proceso más del contenedor entonces
# entiende el SIGTERM directamente. Esto es importante debido a cómo Docker
# interactua con el contenedor al ejecutar Ctrl + C (Gracefull Exit).